"use strict";(self.webpackChunkfront_end_interview_questions=self.webpackChunkfront_end_interview_questions||[]).push([[32],{6845:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=n(4848),i=n(8453);const r={},o="Testing (questions prepared)",a={id:"answers/testing",title:"Testing (questions prepared)",description:"1. Tell us about the testing pyramid. What is the difference between a unit test and a functional/integration test? e2e?",source:"@site/docs/answers/testing.md",sourceDirName:"answers",slug:"/answers/testing",permalink:"/docs/answers/testing",draft:!1,unlisted:!1,editUrl:"https://github.com/pathliving/front-end-interview-questions/docs/answers/testing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React",permalink:"/docs/answers/react"},next:{title:"Fundamentals",permalink:"/docs/answers/fundamentals"}},d={},c=[];function l(e){const t={h1:"h1",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"testing-questions-prepared",children:"Testing (questions prepared)"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Tell us about the testing pyramid. What is the difference between a unit test and a functional/integration test? e2e?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The testing pyramid is a concept that advocates for having more low-level tests (unit tests) than high-level tests (end-to-end tests). It typically consists of three layers:\nUnit Tests: Test individual components or functions in isolation. They are fast, reliable, and form the base of the pyramid.\nIntegration Tests: Test the interaction between integrated units or services. They ensure that combined components work together correctly.\nEnd-to-End (E2E) Tests: Test the entire application workflow from start to finish. They simulate real user scenarios to ensure the system works as expected. These are fewer in number and more complex and time-consuming than unit or integration tests."}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsx)(t.li,{children:"What are some of the testing best practices?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Write clear and concise test cases.\nEnsure tests are independent and can run in any order.\nUse meaningful test names and organize tests logically.\nMock external dependencies to isolate units.\nMaintain a balance between different types of tests (unit, integration, E2E).\nAutomate tests as much as possible.\nRun tests frequently and integrate them into the CI/CD pipeline.\nEnsure tests are maintainable and easy to understand.\nRegularly review and refactor tests to improve their quality."}),"\n",(0,s.jsxs)(t.ol,{start:"3",children:["\n",(0,s.jsx)(t.li,{children:"Functional testing vs TDD (test-driven-development) vs CDT (code-driven-testing) vs BDD (Behavior Driven Development)?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Functional Testing: Validates the software system against functional requirements/specifications. It involves testing individual functions or features.\nTest-Driven Development (TDD): A development process where tests are written before writing the code. The cycle follows: write a test, write code to pass the test, refactor, and repeat.\nCode-Driven Testing (CDT): Tests are written based on the existing codebase. It is less formal than TDD and often follows traditional development.\nBehavior-Driven Development (BDD): Extends TDD by focusing on the behavior of the application from the user's perspective. It uses natural language constructs to define test cases, often involving collaboration between developers, testers, and business stakeholders."}),"\n",(0,s.jsxs)(t.ol,{start:"4",children:["\n",(0,s.jsx)(t.li,{children:"What is A/B testing?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"A/B testing is a method of comparing two versions of a webpage or app against each other to determine which one performs better. Users are randomly assigned to either the control group (A) or the variant group (B), and their interactions are measured to identify the more effective variant."}),"\n",(0,s.jsxs)(t.ol,{start:"5",children:["\n",(0,s.jsx)(t.li,{children:"What is AAA in testing?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"AAA stands for Arrange, Act, Assert. It is a pattern used to structure test cases:\nArrange: Set up the initial conditions and inputs.\nAct: Execute the code or functionality being tested.\nAssert: Verify that the expected outcome has occurred."}),"\n",(0,s.jsxs)(t.ol,{start:"6",children:["\n",(0,s.jsx)(t.li,{children:"How to ensure consistency of test results in different environments (development, testing, production)?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Use environment-agnostic configurations and avoid hard-coded values.\nEnsure the same versions of dependencies are used across environments.\nMock or stub external services and dependencies.\nUse containerization (e.g., Docker) to replicate environments.\nImplement CI/CD pipelines to automate deployment and testing processes.\nRun tests in isolated environments to avoid interference from other processes."}),"\n",(0,s.jsxs)(t.ol,{start:"7",children:["\n",(0,s.jsx)(t.li,{children:'How do you determine when a software product is ready for release? What criteria do you use for a "green light" for a release?'}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Ensure all critical bugs and high-priority issues are resolved.\nConfirm that the application passes all automated tests (unit, integration, E2E).\nConduct thorough manual testing and user acceptance testing (UAT).\nVerify that performance and load tests meet the required benchmarks.\nEnsure documentation is complete and up-to-date.\nConduct a final review meeting with stakeholders to agree on readiness.\nEnsure the deployment process has been tested and is reliable."}),"\n",(0,s.jsxs)(t.ol,{start:"8",children:["\n",(0,s.jsx)(t.li,{children:"Do you know the chaos engineering approach, if so, how can it be applied on the frontend?"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Chaos engineering involves deliberately introducing faults and disruptions into a system to identify weaknesses and improve resilience. On the frontend, it can be applied by:\nSimulating network outages or latency to test the app's offline handling and performance.\nIntroducing random errors or delays in API responses to test error handling and user experience under failure conditions.\nTesting with varying screen sizes and resolutions to ensure responsive design holds up.\nUsing tools like Gremlins.js to introduce chaotic events such as random user interactions or state changes."})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}}}]);