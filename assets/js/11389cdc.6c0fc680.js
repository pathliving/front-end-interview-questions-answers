"use strict";(self.webpackChunkfront_end_interview_questions=self.webpackChunkfront_end_interview_questions||[]).push([[819],{8453:(e,n,s)=>{s.d(n,{R:()=>a});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}},8562:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var t=s(4848),i=s(8453);const r={},a="Javascript",o={id:"answers/javascript",title:"Javascript",description:"1. What is strict mode? What are some of the advantages/disadvantages of using it?",source:"@site/docs/answers/javascript.md",sourceDirName:"answers",slug:"/answers/javascript",permalink:"/front-end-interview-questions-answers/docs/answers/javascript",draft:!1,unlisted:!1,editUrl:"https://github.com/pathliving/front-end-interview-questions/docs/answers/javascript.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CSS",permalink:"/front-end-interview-questions-answers/docs/answers/css"},next:{title:"Typecript",permalink:"/front-end-interview-questions-answers/docs/answers/typescript"}},c={},l=[];function d(e){const n={code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"javascript",children:"Javascript"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is strict mode? What are some of the ",(0,t.jsx)(n.code,{children:"advantages/disadvantages"})," of using it?\nStrict mode is a way to opt in to a restricted variant of JavaScript, introduced in ECMAScript 5. It eliminates some silent errors, improves performance by enabling optimizations, and prevents certain actions that are likely to be bugs (e.g., using undeclared variables). However, it can be restrictive and might break legacy code."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Have you ever used JavaScript templating? If so, what libraries have you used?\nYes, I have used JavaScript templating. Some popular libraries include Handlebars.js, Mustache.js, and EJS. These libraries help in generating HTML with dynamic data more efficiently."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is the difference between an attribute and a property?\nAttributes are defined in the HTML and represent initial values. Properties are part of the DOM and can change over time. For example, the value attribute of an ",(0,t.jsx)(n.code,{children:"<input>"})," sets the initial value, while the value property reflects the current value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are the pros and cons of extending built-in JavaScript objects?\nPros: Can add new functionality or improve existing behavior. Cons: Can lead to conflicts with future ECMAScript versions or other libraries, and can cause unpredictable behavior in code."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is type casting (conversion) in JS?\nType casting (conversion) refers to converting a value from one type to another, such as converting a string to a number using Number(), parseInt(), or parseFloat()."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is type coercion? What are common pitfalls of relying on type coercion in JavaScript code?\nType coercion is JavaScript's automatic conversion of values from one type to another. Common pitfalls include unexpected results due to implicit conversions, like 0 == '' being true."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are explicit and implicit casting (conversion) of data types in JS?\nExplicit casting involves manually converting a value, like Number('123'). Implicit casting happens automatically, such as when adding a number and a string ('1' + 2 results in '12')."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between == and ===?\n== checks for value equality with type coercion, while === checks for both value and type equality. === is generally preferred to avoid unexpected results from type coercion."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why is it called a Ternary operator, what does the word Ternary indicate?\nIt's called a Ternary operator because it takes three operands: a condition, a result if true, and a result if false. Example: condition ? trueResult : falseResult."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What do you know about optional chaining operators? What benefits does it bring?\nOptional chaining (?.) allows safe access to deeply nested properties, returning undefined if a reference is null or undefined, thus preventing runtime errors. It simplifies checking for the existence of properties."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Can you give an example for destructuring an object or an array?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const person = { name: "John", age: 30 };\nconst { name, age } = person;\n\n\nconst arr = [1, 2, 3];\nconst [first, second, third] = arr;\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is Interpolation in JavaScript?\nInterpolation is embedding expressions within string literals using template literals. Example: ",(0,t.jsx)(n.code,{children:"Hello, ${name}!"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Can you give an example of generating a string with ES6 Template Literals?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const name = "John";\nconst message = `Hello, ${name}! Welcome to the team.`;\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are the benefits of using spread syntax and how is it different from rest syntax?\nSpread syntax (...) expands elements of an iterable. Rest syntax collects all remaining elements. Spread is used in arrays and objects, while rest is used in function parameters."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// Spread\nconst arr = [1, 2, 3];\nconst newArr = [...arr, 4, 5];\n\n// Rest\nfunction sum(...numbers) {\n  return numbers.reduce((acc, num) => acc + num, 0);\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"15",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is scope?\nScope determines the visibility of variables. JavaScript has function scope and block scope. Variables declared with var have function scope, while those declared with let and const have block scope."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?\nModifying the global scope can lead to naming conflicts and unpredictable behavior, especially in large codebases or when using third-party libraries."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Describe the difference between let, const, and var. Can you change a property of an object defined via const? How you can change this behavior?\nlet: Block-scoped, can be updated, but not re-declared in the same scope.\nconst: Block-scoped, cannot be updated or re-declared.\nvar: Function-scoped, can be updated and re-declared.\nYes, you can change properties of an object defined with const because const prevents reassigning the variable, but not modifying the object's properties."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const obj = { name: "John" };\nobj.name = "Doe"; // Allowed\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"18",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between a variable that is: null, undefined or undeclared?\nnull: Explicitly assigned no value.\nundefined: Declared but not assigned a value.\nundeclared: Not declared at all in the current scope."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What language constructions do you use for iterating over object properties and array items?\nObjects: for...in loop, Object.keys(), Object.values(), Object.entries().\nArrays: for loop, for...of loop, forEach(), map(), filter(), reduce()."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Can you describe the main difference between the Array.forEach() loop and Array.map() methods and why you would pick one versus the other?\nforEach(): Executes a function for each array element, doesn't return a new array.\nmap(): Executes a function for each array element, returns a new array with the results. Use map() when you need a new transformed array."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between while and do-while loops in JavaScript?\nwhile: Checks the condition before executing the loop body.\ndo-while: Executes the loop body at least once before checking the condition."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What methods of Array mutate and what methods not mutate arrays (sort, reverse, splice, push, pop, shift, unshift - mutate; reduce, map - not mutate)?\nMutate: sort(), reverse(), splice(), push(), pop(), shift(), unshift().\nNot Mutate: reduce(), map(), filter(), slice()."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What does a deep or shallow copy of an object mean? How to do each of them?\nShallow copy: Copies an object's properties but not nested objects. Use Object.assign() or the spread operator (...).\nDeep copy: Copies an object and all nested objects. Use libraries like lodash (_.cloneDeep()) or structuredClone().\njavascript\nCopy code"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// Shallow copy\nconst obj = { a: 1, b: { c: 2 } };\nconst shallowCopy = { ...obj };\n\n// Deep copy\nconst deepCopy = structuredClone(obj);\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"24",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between the in operator and the hasOwnProperty method?\nin: Checks if a property exists in the object or its prototype chain.\nhasOwnProperty: Checks if a property exists directly on the object. 25. What are object property descriptors? Tell about their practical application.\nProperty descriptors define properties' characteristics, such as configurable, enumerable, writable, and value. They allow fine-grained control over object properties. Use Object.defineProperty() to set descriptors."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Describe the purpose and principles of working with Map and Set collections.\nMap: Stores key-value pairs, keys can be any type. Maintains insertion order.\nSet: Stores unique values of any type. No duplicates allowed."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Describe the purpose and principles of working with WeakMap and WeakSet collections? How are they different from Map and Set collections respectively?\nWeakMap: Keys are objects, not enumerable, does not prevent garbage collection.\nWeakSet: Stores unique objects, not enumerable, does not prevent garbage collection."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain the difference between mutable and immutable objects.\nMutable objects: Can be changed after creation.\nImmutable objects: Cannot be changed after creation. Any change creates a new object."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is an example of an immutable object in JavaScript? Name several ways to create an immutable object in JavaScript.\nExample: String is an immutable object.\nTo create immutable objects:"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use Object.freeze().\nUse libraries like Immutable.js.\nUse const for arrays and objects with immutability patterns.\njavascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const frozenObject = Object.freeze({ a: 1 });\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"30",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are the pros and cons of immutability?\nPros: Predictability, easier debugging, safer concurrent programming. Cons: Performance overhead due to copying, increased memory usage."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["How can you achieve immutability in your own code?\nUse ",(0,t.jsx)(n.code,{children:"Object.freeze()"})," for shallow immutability.\nUse libraries like Immutable.js.\nAvoid direct mutations, use pure functions to return new states."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is the difference between the behavior of ",(0,t.jsx)(n.code,{children:"isNaN()"})," and ",(0,t.jsx)(n.code,{children:"Number.isNaN()"}),"?\n",(0,t.jsx)(n.code,{children:"isNaN()"}),": Converts the value to a number and checks if it's NaN, which can lead to false positives.\n",(0,t.jsx)(n.code,{children:"Number.isNaN()"}),": Only returns true if the value is exactly NaN.\njavascript\nCopy code"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'isNaN("hello"); // true\nNumber.isNaN("hello"); // false\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why does typeof null return object?\nDue to a historical bug in JavaScript, typeof null returns object. null was intended to represent a null object reference."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Tell about the Symbol data type and its practical application.\nSymbol is a unique and immutable primitive value used to create unique object keys. Practical uses include defining non-enumerable properties and avoiding property name collisions."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const sym = Symbol("description");\nconst obj = { [sym]: "value" };\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"35",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is it iterator and generator?\nIterator: An object with a ",(0,t.jsx)(n.code,{children:"next()"})," method that returns ",(0,t.jsx)(n.code,{children:"{ value, done }"})," pairs.\nGenerator: A function that can pause and resume execution, defined using ",(0,t.jsx)(n.code,{children:"function\\*"})," syntax, and returns an iterator."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"How we know when generator finish yield values?\nWhen a generator finishes yielding values, the done property in the result object returned by the generator's next() method becomes true."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Javascript pure functions\nPure functions are functions that, given the same inputs, always return the same output and have no side effects. They enhance predictability and ease of testing."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"How do arrow functions differ from regular functions? What advantage is there for using the arrow syntax for a method in a constructor?\nArrow functions do not have their own this binding; they inherit this from the enclosing context. This avoids common issues with this in regular functions, making them ideal for methods in constructors and callbacks."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is a typical use case for anonymous functions?\nAnonymous functions are used as arguments to other functions, such as in callbacks or event handlers, where a named function isn't necessary."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is function chaining? Write an example using this approach.\nFunction chaining involves calling multiple methods on an object in a single statement, returning the object each time. This allows for a fluent interface."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Car {\n  constructor() {\n    this.speed = 0;\n  }\n  accelerate() {\n    this.speed += 10;\n    return this;\n  }\n  brake() {\n    this.speed -= 5;\n    return this;\n  }\n}\n\nconst car = new Car();\ncar.accelerate().accelerate().brake(); // Method chaining\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"41",children:["\n",(0,t.jsx)(n.li,{children:"What is IIFE (Immediately Invoked Function Expression)?\nAn IIFE is a function that runs as soon as it is defined. It is used to create a new scope and avoid polluting the global scope."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'(function () {\n  console.log("IIFE runs immediately");\n})();\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"42",children:["\n",(0,t.jsx)(n.li,{children:"What is Currying function?\nCurrying is the process of transforming a function with multiple arguments into a sequence of functions that each take a single argument."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const add = (a) => (b) => a + b;\nconst addFive = add(5);\nconsole.log(addFive(3)); // 8\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"43",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is recursion? When is the use of recursion useful in Javascript?\nRecursion is a technique where a function calls itself. It is useful for tasks that can be divided into similar subtasks, such as tree traversal and factorial calculation."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the definition of a higher-order function?\nA higher-order function is a function that takes other functions as arguments or returns a function as a result. Examples include map(), filter(), and reduce()."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Explain the difference between: ",(0,t.jsx)(n.code,{children:"function Person(){}, var person = Person()"}),", and ",(0,t.jsx)(n.code,{children:"var person = new Person()"}),"?\n",(0,t.jsx)(n.code,{children:"function Person() {}"}),": Defines a function.\n",(0,t.jsx)(n.code,{children:"var person = Person()"}),": Invokes the Person function, assigning its return value to person.\n",(0,t.jsx)(n.code,{children:"var person = new Person()"}),": Creates a new instance of the Person object using the constructor function."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Explain the differences on the usage of foo between ",(0,t.jsx)(n.code,{children:"function foo() {}"})," and ",(0,t.jsx)(n.code,{children:"var foo = function() {}"}),"?\n",(0,t.jsx)(n.code,{children:" function foo() {}"}),": Function declaration, hoisted.\n",(0,t.jsx)(n.code,{children:"var foo = function() {}"}),": Function expression, not hoisted."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain the concept of this in JavaScript. Can you give an example of one of the ways that working with this has changed in ES6?\nthis refers to the context in which a function is called. In ES6, arrow functions do not have their own this binding; they inherit it from the enclosing lexical context."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function Person() {\n  this.age = 0;\n  setInterval(() => {\n    this.age++; // `this` refers to the Person instance\n  }, 1000);\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"48",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between host objects and native objects?\nHost objects: Provided by the environment (e.g., browser-specific objects like window, document).\nNative objects: Defined by the ECMAScript specification (e.g., Object, Array). 49. Explain Function.prototype.bind. What is context lossing, when does it happen, and how can it be prevented?\nbind creates a new function with a specified this value and arguments. Context loss occurs when this is lost, often in callbacks. Using bind can prevent this by explicitly setting the context."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Can you explain what Function.call and Function.apply do? What is the notable difference between the two?\ncall: Invokes a function with a specified this value and arguments provided individually.\napply: Invokes a function with a specified this value and arguments provided as an array."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the problem throttling and debouncing are resolved? What is the core difference between them?\nThrottling limits the number of times a function can execute over time. Debouncing ensures a function is only called once after a specified delay after it stops being invoked. Both address performance issues with repeated function calls."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Give an example of a function with memoization. When should this technique be used?\nMemoization caches function results to optimize performance for expensive operations. Use it for functions with repetitive calls and predictable results."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const memoize = (fn) => {\n  const cache = {};\n  return (...args) => {\n    const key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = fn(...args);\n    }\n    return cache[key];\n  };\n};\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"53",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are the differences between ES6 class and ES5 function constructors?\nES6 class: Syntactic sugar over prototypes, clearer and more concise syntax.\nES5 function constructors: Uses functions and prototype chaining, more verbose."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What are closures and how do they work?\nClosures are functions that retain access to their lexical scope even when executed outside that scope. They enable private variables and persistent state."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain hoisting.\nHoisting is JavaScript's behavior of moving variable and function declarations to the top of their containing scope during the compile phase. This means functions and variables can be used before they are declared."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is temporal dead zone?\nThe temporal dead zone (TDZ) is the time between entering a block scope and the point where a variable declared with let or const is initialized. Accessing the variable in this period throws a ReferenceError."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"How does prototypal inheritance work?\nPrototypal inheritance allows objects to inherit properties and methods from other objects. Objects are linked via their prototype, enabling shared behavior."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Is it possible to write new ",(0,t.jsx)(n.code,{children:"properties / functions"})," in prototypes of standard classes (Array, Object, etc.)? Why not? In what cases can this be done? How to protect yourself if you need to expand the prototype?\nWhile possible, modifying prototypes of standard classes is discouraged due to potential conflicts and unpredictable behavior. Use caution and ensure compatibility by checking for existing properties."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Explain the difference between synchronous and asynchronous functions.\nSynchronous functions: Block execution until they complete.\nAsynchronous functions: Do not block execution; use callbacks, promises, or ",(0,t.jsx)(n.code,{children:"async/await"})," for handling results."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is event loop?\nThe event loop is a mechanism that manages the execution of asynchronous code in JavaScript, ensuring non-blocking behavior by handling events and callbacks in a loop. Resources: ",(0,t.jsx)(n.code,{children:"https://www.youtube.com/watch?v=eiC58R16hb8"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between call stack and task queue?\nCall stack: Manages the execution of function calls.\nTask queue: Holds asynchronous tasks to be executed after the current call stack is empty."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between Observable and Promise?\nObservable: Represents multiple values over time, can be canceled, and has operators for processing streams.\nPromise: Represents a single value at a future point in time, cannot be canceled."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Explain how Promises work in JavaScript (methods all, allSettled, race, any)\nPromises: Represent an eventual completion (or failure) of an asynchronous operation.\nall: Resolves when all promises resolve, or rejects if any promise rejects.\nallSettled: Resolves when all promises settle (either resolve or reject).\nrace: ",(0,t.jsx)(n.code,{children:"Resolves/rejects"})," as soon as one promise ",(0,t.jsx)(n.code,{children:"resolves/rejects"}),".\nany: Resolves as soon as any promise resolves, or rejects if all promises reject."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is the extent of your experience with Promises ",(0,t.jsx)(n.code,{children:"and/or"})," their polyfills?\nPromises are fundamental in modern JavaScript for handling asynchronous operations. Polyfills like babel-polyfill can ensure compatibility in older environments."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'What are the pros and cons of using Promises instead of callbacks?\nPros: Better readability, easier error handling, chaining for sequential operations. Cons: Slightly more complex syntax for beginners, potential overuse leading to "promise hell."'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["How would you handle errors in ",(0,t.jsx)(n.code,{children:"async/await"}),"?\nUse ",(0,t.jsx)(n.code,{children:"try...catch"})," blocks to handle errors in ",(0,t.jsx)(n.code,{children:"async/await"}),":"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'async function fetchData() {\n  try {\n    const response = await fetch("url");\n    const data = await response.json();\n  } catch (error) {\n    console.error(error);\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"67",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain Ajax in as much detail as possible. What are the advantages and disadvantages of using Ajax?\nAjax (Asynchronous JavaScript and XML) enables asynchronous data retrieval without refreshing the page. Advantages: Improved user experience, partial page updates. Disadvantages: Complexity, browser compatibility issues, can increase server load."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Explain how JSONP works (and how it's not really Ajax).\nJSONP (JSON with Padding) allows cross-domain requests by embedding script tags. It is not true Ajax since it uses ",(0,t.jsx)(n.code,{children:"<script>"})," for data fetching, lacking XHR features."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is JSON and how to work with it in JavaScript?\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. Use JSON.stringify() to convert objects to JSON strings, and JSON.parse() to parse JSON strings into objects."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What are JSON and XML and how do they differ in use?\nJSON is lightweight, easy to ",(0,t.jsx)(n.code,{children:"read/write"}),", and integrates seamlessly with JavaScript. XML is verbose, supports attributes and complex structures, and is used in legacy systems."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain event delegation.\nEvent delegation involves attaching a single event listener to a parent element to manage events for its children, leveraging event bubbling."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Describe event bubbling.\nEvent bubbling is the process where an event propagates from the target element up through the DOM hierarchy, triggering handlers on ancestors."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Describe event capturing.\nEvent capturing (or trickling) is the phase where an event propagates from the root to the target element. It's the opposite of bubbling."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is the difference between ",(0,t.jsx)(n.code,{children:"event.target"})," and ",(0,t.jsx)(n.code,{children:"event.currentTarget"}),"?\n",(0,t.jsx)(n.code,{children:"event.target"}),": The element that triggered the event.\n",(0,t.jsx)(n.code,{children:"event.currentTarget"}),": The element to which the event handler is attached."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is the difference between ",(0,t.jsx)(n.code,{children:"event.preventDefault()"})," and ",(0,t.jsx)(n.code,{children:"event.stopPropagation()"}),"?\n",(0,t.jsx)(n.code,{children:"event.preventDefault()"}),": Prevents the default action associated with the event.\n",(0,t.jsx)(n.code,{children:"event.stopPropagation()"}),": Stops the event from bubbling or capturing."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["EventEmitter js and custom events\nEventEmitter is a pattern for handling custom events. In JavaScript, it is implemented using EventEmitter in ",(0,t.jsx)(n.code,{children:"Node.js"})," or custom event systems in browsers."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["How does",(0,t.jsx)(n.code,{children:" boxing"})," and ",(0,t.jsx)(n.code,{children:"unboxing"})," work in JavaScript?\nBoxing wraps primitive values in object wrappers (Number, String, etc.). Unboxing extracts the primitive value from the wrapper."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What ways do you know to detect whether an element is in the user's viewport?\ngetBoundingClientRect()\nIntersection Observer API"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["When would you use ",(0,t.jsx)(n.code,{children:"document.write()"}),"?\nUse ",(0,t.jsx)(n.code,{children:"document.write()"})," for debugging or inserting content during initial page load. It's generally avoided due to potential issues with existing content."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Difference between document load event and document DOMContentLoaded event?\nload: Fired when the entire page, including resources, is loaded.\nDOMContentLoaded: Fired when the HTML is fully loaded and parsed, without waiting for resources."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why would you use something like the load event? Does this event have disadvantages? Do you know any alternatives, and why would you use those?\nUse the load event to ensure all resources are loaded. Disadvantages include delayed execution. Alternatives include DOMContentLoaded for faster interaction or IntersectionObserver for specific resource tracking."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the difference between feature detection, feature inference, and using the UA string?\nFeature detection: Checking if a feature exists in the browser (e.g., if ('geolocation' in navigator)).\nFeature inference: Assuming features based on other known features.\nUA string: Using the user agent string to infer browser capabilities, less reliable."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Discuss how you might use Object Oriented Programming (OOP) principles when coding with JavaScript. (inheritance, encapsulation, abstraction, polymorphism)\nOOP in JavaScript involves creating classes and objects to model real-world entities. Use inheritance for shared behavior, encapsulation for hiding implementation details, abstraction for defining interfaces, and polymorphism for different implementations."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What patterns do you know and successfully use in JavaScript?\nSingleton: Ensures a class has only one instance.\nModule: Encapsulates related functions and variables.\nObserver: Manages subscription and notification of events.\nFactory: Creates objects without specifying the exact class."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Implementation of the Class Free OOP pattern\nRefer to observablehq.com for implementation details."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Implementation of Async Disposer pattern\nRefer to advancedweb.hu for implementation details."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why you might want to create static class members?\nStatic members belong to the class itself, not instances. Use them for utility functions or shared data that doesn't change per instance."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the purpose of creating an abstract class?\nAbstract classes cannot be instantiated directly. They define common behavior and must be subclassed, ensuring derived classes implement specific methods."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Why is the Proxy constructor needed? Give an example of use.\nProxy is used to intercept and customize operations on objects (e.g., property access, assignment). Example: Logging property accesses."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"javascript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const handler = {\n  get: (target, prop) => {\n    console.log(`Property ${prop} accessed`);\n    return target[prop];\n  },\n};\nconst proxy = new Proxy({}, handler);\nproxy.a = 10;\nconsole.log(proxy.a);\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"90",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is an ArrayBuffer? What is the difference between Uint32Array and Float32Array? What is the result of executing the code?\nArrayBuffer represents a fixed-length raw binary data buffer. Uint32Array stores unsigned 32-bit integers, Float32Array stores 32-bit floating-point numbers. The result of execution depends on the context provided."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What tools and techniques do you use debugging JavaScript code?\nDeveloper tools: Console, breakpoints, step-through debugging.\nLinters: ESLint.\nTesting frameworks: Jest, Mocha.\nDebugging techniques: Logging, ",(0,t.jsx)(n.code,{children:"try...catch"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is Javascript source maps?\nSource maps map compiled code back to its original source code, aiding debugging by showing the original code in developer tools."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["How can you share code between files?\n",(0,t.jsx)(n.code,{children:"Modules"}),": import and export (ES6).\n",(0,t.jsx)(n.code,{children:"CommonJS"}),": require and module.exports.\n",(0,t.jsx)(n.code,{children:"AMD/UMD"}),": For asynchronous module loading."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["What is ",(0,t.jsx)(n.code,{children:"CJS (Commonjs), AMD/UMD, ESM"}),"? And what is the difference between them?\nCJS (CommonJS): Synchronous module system used in Node.js.\nAMD (Asynchronous Module Definition): Asynchronous module system for browsers.\nUMD (Universal Module Definition): Works with both CJS and AMD.\nESM (ES Modules): Standardized module system in ES6, uses ",(0,t.jsx)(n.code,{children:"import/export"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is NPM and Yarn? What are the differences?\nNPM: Default package manager for Node.js. Yarn: Alternative package manager, faster installs, and deterministic lock files."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Explain synchronous module definition\nSynchronous module definition loads modules synchronously, blocking execution until dependencies are resolved. Used in CJS."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"How to define and use types in TypeScript?\nDefine types using interfaces, type aliases, or enums. Use them to ensure type safety in variables, functions, and classes."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"typescript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'interface User {\n  name: string;\n  age: number;\n}\n\nconst user: User = { name: "John", age: 30 };\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"98",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Tell about Interface Oriented Programming in TS.\nInterface-oriented programming focuses on defining interfaces to establish contracts for objects. It emphasizes the use of interfaces over concrete implementations."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is duck typing in TypeScript? Provide a code example.\nDuck typing allows objects to be used based on their shape rather than explicit type definitions."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"typescript\nCopy code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'interface CanSwim {\n  swim(): void;\n}\n\nconst swimmer: CanSwim = { swim: () => console.log("Swimming") };\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);